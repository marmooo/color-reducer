class UniformQuantization{constructor(e){this.imageData=e}getReplaceColors(e){const t=Math.floor(Math.cbrt(e)),o=new Array(t**3),n=256/t,s=n/2;let i=0;for(let e=0;e<t;e++)for(let a=0;a<t;a++)for(let r=0;r<t;r++){const c=Math.round(n*e+s),l=Math.round(n*a+s),d=Math.round(n*r+s);o[i]={r:c,g:l,b:d},i++}return o}getIndexedImage(e){const{imageData:n}=this,t=Math.floor(Math.cbrt(e)),a=new Uint32Array(n.data.buffer),s=n.width*n.height,i=t<7?new Uint8Array(s):new Uint16Array(s),o=256/t;for(let e=0;e<s;e++){const n=a[e],r=n>>24&255,c=n>>16&255,l=n>>8&255,d=Math.floor(l/o),u=Math.floor(c/o),h=Math.floor(r/o);i[e]=(h*t+u)*t+d}return i}apply(e){const{imageData:o}=this,a=Math.floor(Math.cbrt(e)),t=256/a,i=t/2,n=o.data,s=new Uint8ClampedArray(n.length);for(let e=0;e<n.length;e+=4){const o=e+1,a=e+2,r=e+3;s[e]=Math.round(Math.floor(n[e]/t)*t+i),s[o]=Math.round(Math.floor(n[o]/t)*t+i),s[a]=Math.round(Math.floor(n[a]/t)*t+i),s[r]=n[r]}return new ImageData(s,o.width,o.height)}}export{UniformQuantization as UniformQuantization};class OctreeNode{colors=[];total=0;constructor(e){this.level=e}}class OctreeLog{constructor(e,t){this.cubeIndex=e,this.numLeaves=t}}class OctreeQuantization{replaceColors;colorMapping;splitLogs=[];constructor(e){this.imageData=e,this.cubes=this.initCubes()}getKey(e,t){const n=(e>>16+t&1)<<2,s=(e>>8+t&1)<<1,o=e>>t&1;return n|s|o}initCubes(){const{imageData:o}=this,n=new Uint32Array(o.data.buffer),t=new Uint32Array(16777216);for(let e=0;e<n.length;e++){const s=n[e],o=s&16777215;t[o]++}const i=7,e=new Array(8);for(let t=0;t<e.length;t++)e[t]=new OctreeNode(i);for(let n=0;n<t.length;n++){const s=t[n];if(s){const o=this.getKey(n,7),t=e[o];t.colors.push([n,s]),t.total+=s}}const s=e.filter(e=>e.total>0);return this.splitLogs=[new OctreeLog(0,s.length)],s}splitCubes(e,t){const{splitLogs:n}=this;for(;e.length<t;){let i=0,a=e[0].total;for(let t=1;t<e.length;t++){const n=e[t],s=n.total;a<s&&n.level!==0&&(i=t,a=s)}const o=e[i];if(o.total===1)break;if(o.colors.length===1)break;const r=o.level-1;let s=new Array(8);for(let e=0;e<s.length;e++)s[e]=new OctreeNode(r);for(let e=0;e<o.colors.length;e++){const[t,n]=o.colors[e],a=this.getKey(t,r),i=s[a];i.colors.push([t,n]),i.total+=n}if(s=s.filter(e=>e.total>0),e.length+s.length-1<=t){e.splice(i,1,...s);const t=new OctreeLog(i,s.length);n.push(t)}else break}return e}mergeCubes(e,t){const{splitLogs:n}=this;let s=n.length-1;for(;t<e.length;){const{cubeIndex:o,numLeaves:i}=n[s],t=e[o];for(let n=1;n<i;n++){const s=e[o+n];t.colors.push(...s.colors),t.total+=s.total}t.level++,e.splice(o,i,t),s--}return this.splitLogs=n.slice(0,s+1),e}getReplaceColors(e){const{colorMapping:n}=this,t=new Array(e.length);for(let s=0;s<e.length;s++){const i=e[s].colors;let a=0,r=0,c=0,o=0;for(let l=0;l<i.length;l++){const[e,t]=i[l],d=e>>16&255,u=e>>8&255,h=e&255;a+=h*t,r+=u*t,c+=d*t,o+=t,n[e]=s}const l=Math.round(a/o),d=Math.round(r/o),u=Math.round(c/o),h=(u*256+d)*256+l;t[s]=h}return t}getIndexedImage(){const{imageData:t,replaceColors:s}=this,o=new Uint8Array(this.imageData.data.length),e=t.width*t.height,n=s.length<=256?new Uint8Array(e):new Uint16Array(e);for(let t=0;t<e;t++){const s=o[t],i=s&16777215;n[t]=this.colorMapping[i]}return n}initColorMapping(e){const{colorMapping:t}=this;return e<=256?t instanceof Uint8Array||(this.colorMapping=new Uint8Array(16777216)):t instanceof Uint16Array||(this.colorMapping=new Uint16Array(16777216)),this.colorMapping}apply(e){const{imageData:n}=this;let{cubes:t}=this;t=e<t.length?this.mergeCubes(t,e):this.splitCubes(t,e),this.cubes=t;const a=this.initColorMapping(t.length),o=this.getReplaceColors(t);this.replaceColors=o;const s=new Uint32Array(n.data.buffer),i=new Uint32Array(s.length);for(let e=0;e<s.length;e++){const t=s[e],n=t&16777215,r=o[a[n]];i[e]=r|t&4278190080}const r=new Uint8ClampedArray(i.buffer);return new ImageData(r,n.width,n.height)}}export{OctreeNode as OctreeNode};export{OctreeLog as OctreeLog};export{OctreeQuantization as OctreeQuantization};class Cube{constructor(e,t){this.colors=e,this.sortIndex=t,this.calculateCubeProperties()}calculateCubeProperties(){const e=this.getColorStats(this.colors),{rangeR:t,rangeG:n,rangeB:s}=e;this.total=e.total,this.type=this.getDominantColorType(t,n,s)}getDominantColorType(e,t,n){return e>t&&e>n?"r":t>e&&t>n?"g":n>e&&n>t?"b":"g"}getColorStats(e){let r=0,t=0,n=0,s=0,o=255,i=255,a=255;for(let c=0;c<e.length;c++){const[l,d,u,h]=e[c];t=Math.max(t,l),n=Math.max(n,d),s=Math.max(s,u),o=Math.min(o,l),i=Math.min(i,d),a=Math.min(a,u),r+=h}return{total:r,rangeR:t-o,rangeG:n-i,rangeB:s-a}}}class MedianCutLog{constructor(e,t,n){this.cubeIndex=e,this.sortIndex=t,this.type=n}}class MedianCut{replaceColors;colorMapping;splitLogs=[];constructor(e,t={cache:!0}){this.imageData=e,this.options=t,this.colors=this.getColors(),this.cubes=this.initCubes()}initCubes(){return[new Cube(this.colors,-1)]}getColors(){const{imageData:s}=this,t=new Uint32Array(s.data.buffer),e=new Uint32Array(16777216);for(let n=0;n<t.length;n++){const s=t[n],o=s&16777215;e[o]++}const n=[];for(let t=0;t<e.length;t++){const s=e[t];if(s>0){const e=t>>16&255,o=t>>8&255,i=t&255;n.push([i,o,e,s])}}return n}bucketSort(e,t){const{options:s}=this,n=new Array(256);for(let e=0;e<256;e++)n[e]=[];for(let s=0;s<e.length;s++){const o=e[s];n[o[t]].push(o)}if(s.cache){const e=(t+1)%3,s=(t+2)%3;for(let t=0;t<256;t++)n[t].sort((t,n)=>t[e]!==n[e]?t[e]-n[e]:t[s]-n[s])}return n}splitBuckets(e,t){const n=[],s=[];let o=0;for(let i=0;i<256;i++){const a=e[i],r=a.length;if(o+r<=t)n.push(...a),o+=r;else{const r=t-o;n.push(...a.slice(0,r)),s.push(...a.slice(r));for(let t=i+1;t<256;t++)s.push(...e[t]);break}}return[n,s]}sortAndSplit(e,t){const n=this.bucketSort(e,t),s=Math.floor((e.length+1)/2);return this.splitBuckets(n,s)}splitCubesByMedian(e,t){const{splitLogs:n}=this;for(;e.length<t;){let s=0,i=e[0].total;for(let t=1;t<e.length;t++){const n=e[t],o=n.total;i<o&&n.colors.length!==1&&(s=t,i=o)}const t=e[s];if(t.total===1)break;const o="rgb".indexOf(t.type),[a,r]=this.sortAndSplit(t.colors,o),c=new Cube(a,o),l=new Cube(r,o);e.splice(s,1,c,l);const d=new MedianCutLog(s,t.sortIndex,t.type);n.push(d)}return e}mergeCubesByMedian(e,t){const{splitLogs:n}=this;let s=n.length-1;for(;t<e.length;){const{cubeIndex:o,sortIndex:c,type:l}=n[s],t=e[o],i=e[o+1];t.colors.push(...i.colors);const a=this.bucketSort(t.colors,c),r=[];for(let e=0;e<a.length;e++)r.push(...a[e]);t.colors=r,t.total+=i.total,t.type=l,e.splice(o,2,t),s--}return this.splitLogs=n.slice(0,e.length-1),e}getReplaceColors(e){const{colorMapping:n}=this,t=new Array(e.length);for(let s=0;s<e.length;s++){const i=e[s].colors;let a=0,r=0,c=0,o=0;for(let t=0;t<i.length;t++){const[l,d,u,e]=i[t];a+=l*e,r+=d*e,c+=u*e,o+=e;const h=(u*256+d)*256+l;n[h]=s}const l=Math.round(a/o),d=Math.round(r/o),u=Math.round(c/o),h=(u*256+d)*256+l;t[s]=h}return t}getIndexedImage(){const{imageData:e,replaceColors:s,colorMapping:o}=this,i=new Uint8Array(e.data.length),t=e.width*e.height,n=s.length<=256?new Uint8Array(t):new Uint16Array(t);for(let e=0;e<t;e++){const s=i[e],a=s&16777215;n[e]=o[a]}return n}initColorMapping(e){const{colorMapping:t}=this;return e<=256?t instanceof Uint8Array||(this.colorMapping=new Uint8Array(16777216)):t instanceof Uint16Array||(this.colorMapping=new Uint16Array(16777216)),this.colorMapping}apply(e){const{imageData:n,options:a}=this;let{cubes:t}=this;a.cache?t=e<t.length?this.mergeCubesByMedian(t,e):this.splitCubesByMedian(t,e):(e<t.length&&(t=this.initCubes()),t=this.splitCubesByMedian(t,e)),this.cubes=t;const r=this.initColorMapping(e),o=this.getReplaceColors(t);this.replaceColors=o;const s=new Uint32Array(n.data.buffer),i=new Uint32Array(s.length);for(let e=0;e<s.length;e++){const t=s[e],n=t&16777215,a=o[r[n]];i[e]=a|t&4278190080}const c=new Uint8ClampedArray(i.buffer);return new ImageData(c,n.width,n.height)}}export{Cube as Cube};export{MedianCutLog as MedianCutLog};export{MedianCut as MedianCut}